<!-- https://tweetdeck.dimden.dev/solver.html をそのまま移植したもの -->
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="twitter-site-verification" content="loading" />
  </head>
  <body>
    This page is used to solve security challenge given by Twitter. You're free
    to check it's source code to make sure it's safe.
    <div id="anims"></div>
    <script>
      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      let initError = false,
        solver;
      window.addEventListener("message", async function (event) {
        // if (
        //   event.origin !== "https://twitter.com" &&
        //   event.origin !== "https://x.com"
        // ) {
        //   return;
        // }
        // 同一オリジンからのメッセージのみを受け付ける
        if (event.origin !== location.origin) {
          return;
        }
        let data = event.data;
        // console.log("Solver got message", data);
        if (data.action === "init") {
            try {
                window.__SCRIPTS_LOADED__ = {
                    runtime: true
                };
                eval(data.vendor);
                let animsDiv = document.getElementById("anims");
                for (let anim of data.anims) {
                    animsDiv.innerHTML += `\n${anim}`;
                }
                let verif = document.querySelector(
                    'meta[name="twitter-site-verification"]'
                );
                verif.content = data.verificationCode;
                let headerRegex = /(\d+):(.+)=>.+default:\(\)=>(\w)}\);/;
                let headerMatch = data.challenge.match(headerRegex);
                if (!headerMatch) {
                    console.error(
                    "Uh oh, header not found!! Report to https://github.com/dimdenGD/OldTweetDeck/issues"
                    );
                    event.source.postMessage({ action: "initError" }, event.origin);
                    initError = true;
                    return;
                }
                data.challenge = data.challenge.replace(
                    headerRegex,
                    `$1:$2=>{globalThis._ch=()=>$3;`
                );
                eval(data.challenge);
                let id = headerMatch[1];
                // 1) Collect all module factories that have already been pushed
                const chunks = self.webpackChunk_twitter_responsive_web || [];
                const registry = {};
                for (const payload of chunks) {
                    // Each payload looks like: [chunkIds, moreModules, runtime]
                    // where moreModules is an object: { [moduleId]: factory }
                    if (payload && payload[1]) Object.assign(registry, payload[1]);
                }

                // 2) A minimal __webpack_require__ with a cache and a few helpers
                const cache = {};
                function wreq(id) {
                    if (cache[id]) return cache[id].exports;
                    const factory = registry[id];
                    if (!factory) throw new Error("No module with id " + id);

                    const module = { id, loaded: false, exports: {} };
                    cache[id] = module;

                    // Minimal helpers used by many bundles
                    wreq.d = (exports, definition) => {
                        for (const key in definition) {
                            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
                        }
                    };
                    wreq.r = (exports) => {
                        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                            Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
                        }
                            Object.defineProperty(exports, "__esModule", { value: true });
                    };
                    wreq.n = (mod) => {
                        const getter = mod && mod.__esModule ? () => mod.default : () => mod;
                        wreq.d(getter, { a: getter });
                        return getter;
                    };
                    wreq.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);

                    // 3) Execute the module factory: (module, exports, __webpack_require__)
                    factory(module, module.exports, wreq);

                    module.loaded = true;
                    return module.exports;
                }
                webpackChunk_twitter_responsive_web[1][1][id](chunks, cache, wreq);
                solver = globalThis._ch();
                solver = solver();
                event.source.postMessage({ action: "ready" }, event.origin);
                // console.log("Solver initialized successfully");
            } catch (e) {
                console.error("Error while initializing solver", e);
                event.source.postMessage({ action: "initError", error: String(e) }, event.origin);
                initError = true;
            }
        } else if (data.action === "solve") {
          if (initError) {
            event.source.postMessage(
              { action: "error", error: "Initialization error", id: data.id },
              event.origin
            );
            return;
          }
          if (!solver) {
            await sleep(50);
            if (!solver) {
              await sleep(100);
            }
            if (!solver) {
              await sleep(300);
            }
            if (initError || !solver) {
              event.source.postMessage(
                { action: "error", error: "Initialization error", id: data.id },
                event.origin
              );
              return;
            }
          }
          try {
            let result = await solver(data.path, data.method);
            // console.log("Solved", data.path, data.method, result);
            event.source.postMessage(
              { action: "solved", result, id: data.id },
              event.origin
            );
          } catch (e) {
            event.source.postMessage(
              { action: "error", error: e.message, id: data.id },
              event.origin
            );
          }
        }
      });
    </script>
  </body>
</html>
